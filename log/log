final int max = 90000;
		final int min = -90000;
		
		int alpha = min;
		int beta = max;
		
		final int failOffset = 100;
		long nodesSearched = 0;
		boolean skipAdjust = false;
		for(int i = 1; (maxPly == -1 || i <= maxPly) && !cutoffSearch.get() && i <= stackSize; i++){
			s.resetHistory();
			
			if(i <= 3){
				alpha = min;
				beta = max;
			}
			
			if(i > 3 && !skipAdjust){
				/*alpha = score-35;
				beta = score+35;*/
				final int index = i-1-1; //index of most recent score observation
				int est = stats.scores[index];
				est += stats.scores[index-1];
				est /= 2;
				final double dir = stats.scores[index]-stats.scores[index-1];
				est += dir/2;
				alpha = est-35;
				beta = est+35;
				System.out.println("adjusting");
			}
			skipAdjust = false;
			
			System.out.println(alpha+", "+beta);
			
			//System.out.println("starting depth "+i);
			score = recurse(player, alpha, beta, i, true, true, 0, s);
			
			if((score <= alpha || score >= beta) && !cutoffSearch.get()){
				final boolean failLow = score <= alpha;
				if(score <= alpha || score > beta) System.out.println("fail, score = "+score+", fail low = "+failLow);
				if(failLow) alpha -= failOffset;
				else beta += failOffset;
				score = recurse(player, alpha, beta, i, true, true, 0, s);
				if((score <= alpha || score >= beta) && !cutoffSearch.get()){
					final boolean failLow2 = score <= alpha;
					if(score <= alpha || score > beta) System.out.println("fail, score = "+score+", fail low = "+failLow2);
					if(failLow2){
						alpha = min;
						beta = max;
					}
					else{
						beta = max;
						alpha = min;
					}
					if(i < 10){
						score = recurse(player, alpha, beta, i, true, true, 0, s);
					} else{
						i = 3;
						skipAdjust = true;
						continue;
					}
				}
			}